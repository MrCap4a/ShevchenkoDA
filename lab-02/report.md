# Отчет по лабораторной работе №2
## Основные структуры данных. Анализ и применение

**Дата: 20.11.2025**  
**Семестр: 5**  
**Группа: Пиж-б-о-23-2**  
**Дисциплина: анализ сложности алгоритмов**  
**Студент: Шевченко Денис Александрович**  

---

## Цель работы
Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек, связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для решения конкретной задачи, основываясь на анализе теоретической и практической сложности операций. Получить навыки измерения производительности и применения структур данных для решения практических задач.

---

## Теоретическая часть
*   **Список (list) в Python:** Реализация динамического массива. Обеспечивает амортизированное время O(1) для добавления в конец (`append`). Вставка и удаление в середину имеют сложность O(n) из-за сдвига элементов. Доступ по индексу - O(1).
*   **Связный список (Linked List):** Абстрактная структура данных, состоящая из узлов, где каждый узел содержит данные и ссылку на следующий элемент. Вставка и удаление в известное место (например, начало списка) выполняются за O(1). Доступ по индексу и поиск - O(n).
*   **Стек (Stack):** Абстрактный тип данных, работающий по принципу LIFO (Last-In-First-Out). Основные операции: `push` (добавление, O(1)), `pop` (удаление с вершины, O(1)), `peek` (просмотр вершины, O(1)). В Python может быть реализован на основе списка.
*   **Очередь (Queue):** Абстрактный тип данных, работающий по принципу FIFO (First-In-First-Out). Основные операции: `enqueue` (добавление в конец, O(1)), `dequeue` (удаление из начала, O(1)). В Python для эффективной реализации используется `collections.deque`.
*   **Дек (Deque, двусторонняя очередь):** Абстрактный тип данных, позволяющий добавлять и удалять элементы как в начало, так и в конец. Все основные операции - O(1). В Python реализован в классе `collections.deque`.

---

## Практическая часть

### Выполненные задачи
1.  Реализовать класс `LinkedList` (связный список) для демонстрации принципов его работы.
2.  Используя встроенные типы данных, проанализировать эффективность операций, имитирующих поведение стека, очереди и дека.
3.  Провести сравнительный анализ производительности операций для разных структур данных (`list` vs `LinkedList` для вставки, `list` vs `deque` для очереди).
4.  Решить 2-3 практические задачи, выбрав оптимальную структуру данных.

### Ключевые фрагменты кода (Julia)

#### LinkedList
```julia
struct Node
    value::Any
    next::Union{Node, Nothing}
end

mutable struct LinkedList
    head::Union{Node, Nothing}
    tail::Union{Node, Nothing}
end

function LinkedList()
    return LinkedList(nothing, nothing)
end

function insert_at_start(list::LinkedList, value)
    new_node = Node(value, list.head)
    list.head = new_node

    if list.tail === nothing
        list.tail = new_node
    end
end

function insert_at_end(list::LinkedList, value)
    new_node = Node(value, nothing)

    if list.tail === nothing
        list.head = new_node
        list.tail = new_node
    else
        list.tail.next = new_node
        list.tail = new_node
    end
end

function delete_from_start(list::LinkedList)
    if list.head === nothing
        return nothing
    end

    removed = list.head
    list.head = removed.next

    if list.head === nothing
        list.tail = nothing
    end

    return removed.value
end

function traversal(list::LinkedList)
    current = list.head
    while current !== nothing
        println(current.value)
        current = current.next
    end
end
```

#### Сравнение вставки в начало массива и связного списка
```julia
# Вставка в начало массива — O(n)
function test_insert_list(n)
    @benchmark insert!(arr, 1, 1) setup=(arr = collect(1:$n))
end

# Вставка в начало связного списка — O(1)
function test_insert_linked(n)
    @benchmark insert_at_start(ll, 1) setup=(ll = LinkedList())
end
```

#### Сравнение удаления из начала деки и массива
```julia
# Очередь на list — popfirst! O(n)
function test_queue_list(n)
    @benchmark popfirst!(arr) setup=(arr = collect(1:$n)) evals=1000
end

# Очередь на deque — O(1)
function test_queue_deque(n)
    @benchmark popfirst!(dq) setup = (
        dq = begin
            dq_local = Deque{Int}()
            for i in 1:$n
                push!(dq_local, i)
            end
            dq_local
        end
    ) evals=1000
end
```

#### Выполнение задач
```julia
# =================================================================
# ЗАДАЧА 1 — Проверка правильности скобок (stack)
# =================================================================
# Ассимптотика: O(n)
# Что происходит:
#   1. Идём по строке
#   2. Открывающие скобки кладём в стек
#   3. При закрывающей — сравниваем с вершиной
#   4. Если что-то не совпало — скобки не сбалансированы
# =================================================================
function is_balanced(s::String)
    stack = Char[]   # стек на массиве — операции O(1)
    pairs = Dict(')' => '(', ']' => '[', '}' => '{')

    for c in s
        if c in "([{"
            push!(stack, c)
        elseif c in ")]}"
            if isempty(stack) || pop!(stack) != pairs[c]
                return false
            end
        end
    end

    return isempty(stack)
end


# =================================================================
# ЗАДАЧА 2 — Симуляция очереди печати (deque)
# =================================================================
# Ассимптотика: O(n)
# Что происходит:
#   1. Добавляем все задания в deque
#   2. Пока не пуст — достаём по одному с начала
# =================================================================
function simulate_printer(jobs)
    queue = Deque(jobs)

    while !isempty(queue)
        job = popfirst!(queue)   # O(1)
        println("Печать: $job")
    end
end


# =================================================================
# ЗАДАЧА 3 — Палиндром через deque
# =================================================================
# Ассимптотика: O(n)
# Что происходит:
#   1. Записываем строку в deque
#   2. Сравниваем первый и последний символы
#   3. Если не совпали — не палиндром
# =================================================================
function is_palindrome(s::String)
    dq = Deque(collect(s))

    while length(dq) > 1
        if popfirst!(dq) != pop!(dq)
            return false
        end
    end

    return true
end

```
---

### Описание эксперимента
Для замеров производительности использовались встроенные в язык макросы. Перед тестированием создавали заполненные структуры данных, после чего производились замеры времени выполнения операций.

### Построенные графики
В папке report/ находятся изображения:  

Сравнительный график зависимости времени вставки элемента в начало:  
![insert_comparsion.png](report/insert_comparsion.png)

Сравнительный график времени удаления элемента из начала:  
![queue_comparsion.png](report/queue_comparsion.png)  

## Анализ результатов
- Вставка в начало связного списка имеет сложность O(1) и занимает значительно меньше времени, чем вставка в начало обычного списка при любых размерах.
- Удаление из начала обычного списка хорошо оптимизированно и выполняется быстрее удаления из начала деки при размере массива до 1_500_000_000. Далее, из-за того, что сложности удаления из обычного списка O(n), а из деки- O(1), дека начинает работать быстрее.
---

## Выводы
- Связный список значительно быстрее справляется с добавлением или удалением элемента в начало или в конец
- В Julia обычные списки хорошо оптимизированы, из-за чего показывают более быстрый результат даже на больших размерах коллекций данных (до 1_500_000_000 элементов).

---

### Характеристики ПК
* Объем ОЗУ: 24 Гб 
* Скорость ОЗУ: 6400 МТ/с 
* Количество ядер процессора: 8 
* Потоков процессора: 16 
* Частоты процессора: базовая- 3800 MHz, TurboBoost- 5100 MHz 
* Внутренняя память процессора: L1- 8x32+8x32КБ, L2- 8x1024КБ, L3- 16384КБ 
* ОС: Win11 
---

## Ответы на контрольные вопросы

1. В чем ключевое отличие динамического массива от связного списка с точки зрения сложности операций вставки в начало и доступа по индексу?  
У динамического массива (list) вставка в начало стоит O(n), потому что требуется сдвигать все элементы, а доступ по индексу - O(1). У связного списка вставка в начало - O(1), но доступ по индексу - O(n), потому что приходится проходить список последовательно.  
2. Объясните принцип работы стека (LIFO) и очереди (FIFO). Приведите по два примера их практического использования.  
Стек работает по принципу LIFO: последний добавленный элемент извлекается первым. Примеры использования - история отмены действий и стек вызовов программ. Очередь работает по принципу FIFO: первым извлекается самый ранний элемент. Примеры - очередь заданий на печать и обработка сетевых пакетов.  
3. Почему операция удаления первого элемента из списка (list) имеет сложность O(n), а из дека (deque) - O(1)?  
В list удаление первого элемента - O(n), потому что все остальные элементы должны быть сдвинуты. В deque операция - O(1), так как структура реализована через кольцевой буфер, и достаточно изменить указатель на начало.
4. Какую структуру данных вы бы выбрали для реализации системы отмены действий (undo) в текстовом редакторе? Обоснуйте свой выбор.  
Для системы undo лучше всего подходит стек, потому что он напрямую соответствует логике отката: последнее действие отменяется первым, а push/pop выполняются за O(1).  
5. Замеры показали, что вставка 1000 элементов в начало списка заняла значительно больше времени, чем вставка в начало вашей реализации связного списка. Объясните результаты с точки зрения асимптотической сложности.  
Вставка 1000 элементов в начало list работает медленно, потому что каждая вставка - O(n), и суммарно получается квадратичное время. У связного списка вставка в начало - O(1), поэтому даже тысяча таких операций выполняется намного быстрее.

---

## Приложения
- Папка `report/` - содержит графики в виде PNG.
- Исходный код на Julia.
